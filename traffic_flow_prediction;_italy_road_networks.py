# -*- coding: utf-8 -*-
"""Traffic Flow Prediction; Italy Road Networks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hxMyODlU5yel0QIWgqadZUdxHB7PVNDN

## Traffic Flow Prediction; Italy Road Networks

Traffic congestion is a significant issue in urban areas, leading to delays, increased fuel consumption, and environmental pollution. Accurate traffic flow prediction is essential for effective traffic management, urban planning, and improving road safety.

This network consists of nodes representing different locations in Italy and edges representing roads connecting those spots. In this project, the road network of Italy is represented as a graph, where intersections (nodes) are connected by roads (edges). This allows us to analyze the network using deep learning graph theory and machine learning techniques, and to simulate how different factors—such as road closures—affect traffic flow. Furthermore, we implement a Graph Convolutional Network (GCN) to predict traffic flow based on node-level traffic data.
"""

#!pip install nxviz
#!pip install torch-geometric

import networkx as nx
import nxviz as nv
import numpy as np
import matplotlib.pyplot as plt
import random

"""The dataset used in this project is sourced from the Purdue University Network Repository (https://networkrepository.com/index.php). The dataset used for this project comprises traffic flow data from the Italy road network. The edges represent roads, and the nodes signify intersections."""

#Load Roads Network
G = nx.read_edgelist("road-italy-osm.edges", comments='%')

plt.figure(figsize=(14, 9))
nx.draw_networkx_nodes(G, pos=nx.spring_layout(G), node_size=30, node_color=[random.choice(['blue', 'green', 'red', 'yellow', 'orange', 'purple', 'pink', 'cyan', 'magenta']) for _ in range(len(G))])
nx.draw_networkx_edges(G, pos=nx.spring_layout(G))   #these nx.spring_layout(G) determines node positions
nx.draw_networkx_labels(G, pos=nx.spring_layout(G))

"""Each point represents a node (vertex) in the graph."""

#Check stats
print(f"Number of Nodes: {len(G.nodes())}")
print(f"Number of Edges: {len(G.edges())}")

"""Nodes represent specific points or locations in Italy. Edges represent the roads or paths connecting these locations. Each edge between two nodes indicates that there is a road segment connecting those two points."""

#Calculating Assortativity of the graph
assortativity = nx.degree_assortativity_coefficient(G)
assortativity

"""Assortativity measures the tendency of nodes to connect to other nodes that are similar in some way. We got negative assortativity value that suggests a preference for hubs to connect to less connected nodes. While a positive assortativity indicates that nodes tend to connect to other nodes with similar degrees.

### Degree and Betweenness Centrality Calculation

Degree Centrality measures how many connections a node has.
"""

#Degree Centrality
degree_centrality = nx.degree_centrality(G)
degree_centrality

"""Betweenness Centrality measures how often a node acts as a bridge along the shortest path between two other nodes."""

#Betweenness Centrality
betweenness_centrality = nx.betweenness_centrality(G)
betweenness_centrality

#top 5 important nodes based on centrality
top_deg_nodes = sorted(degree_centrality.items(), key=lambda x: x[1], reverse=True)[:5]
top_bet_nodes = sorted(betweenness_centrality.items(), key=lambda x: x[1], reverse=True)[:5]

print("Top 5 nodes by Degree Centrality:", top_deg_nodes)
print("Top 5 nodes by Betweenness Centrality:", top_bet_nodes)

# Plotting the top 5 important nodes

#Degree Centrality
nx.draw(G, with_labels=True, node_size=10, node_color='lightblue', font_size=2, font_weight='bold')
top_deg_labels = {node: node for node, _ in top_deg_nodes}
pos = nx.spring_layout(G)
nx.draw_networkx_nodes(G, pos, nodelist=top_deg_labels.keys(), node_color='orange')
nx.draw_networkx_labels(G, pos, labels=top_deg_labels, font_color='black')
plt.title('Top 5 Nodes by Degree Centrality')

#Betweenness Centrality
nx.draw(G, with_labels=True, node_size=10, node_color='lightblue', font_size=2, font_weight='bold')
top_bet_labels = {node: node for node, _ in top_bet_nodes}
nx.draw_networkx_nodes(G, pos, nodelist=top_bet_labels.keys(), node_color='green')
nx.draw_networkx_labels(G, pos, labels=top_bet_labels, font_color='black')
plt.title('Top 5 Nodes by Betweenness Centrality')

plt.tight_layout()
plt.show()

"""### Clustering: Identifying Road Communities

These clusters represent groups of roads that are more densely connected to each other than to the rest of the network.
"""

from community import community_louvain             #Louvain Modularity

communities = community_louvain.best_partition(G)  # Perform community detection using Louvain
node_colors = [communities[node] for node in G.nodes()]
plt.figure(figsize=(14, 14))
pos = nx.spring_layout(G)
nx.draw(G, pos, node_size=10, node_color=node_colors, edge_color='gray', cmap=plt.cm.get_cmap('rainbow'))
plt.show()

"""### Simulating Road Closures and Their Impact

Simulating Road Closures to assess the impact of road closures on the network.
"""

#Function to remove roads (edges) and analyze network impact
def simulate_road_closure(G, edges_to_remove):
    G_copy = G.copy()
    G_copy.remove_edges_from(edges_to_remove)

    new_centrality = nx.degree_centrality(G_copy)
    num_components = nx.number_connected_components(G_copy)

    print(f"Number of connected components after closure:{num_components}")
    return new_centrality

#Let say randomly simulate closure of 5 random roads
edgesClose = random.sample(list(G.edges()), 5)
newCentrality = simulate_road_closure(G, edgesClose)

"""### Shortest Path Prediction Using Dijkstra’s Algorithm

Dijkstra's algorithm compute the shortest path between two locations in the road network. This is important for traffic flow prediction, as finding efficient routes can alleviate congestion.
"""

# Dijkstra's shortest path algorithm
source_node = '112'   #Sample start node
target_node = '126'   #Sample target node

shortest_path = nx.dijkstra_path(G, source=source_node, target=target_node)
print(f"Shortest path from {source_node} to {target_node}: {shortest_path}")

path_edges = list(zip(shortest_path[:-1], shortest_path[1:]))
plt.figure(figsize=(14, 14))
nx.draw(G, pos, node_size=10, node_color='grey', edge_color='gray')
nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='blue', width=2)
plt.show()

"""### Traffic Flow Prediction Using Graph Convolutional Networks (GCNs)"""

import torch
import torch.nn as nn
from torch_geometric.nn import GCNConv
from torch_geometric.data import Data
from torch.utils.data import random_split
from sklearn.metrics import mean_squared_error

traffic = {node: random.uniform(0, 1) for node in G.nodes()}   #traffic flow at each node; simulating random values for nodes

#tensor- list of traffic values for each node
nodeFeatures = torch.tensor([traffic[node] for node in G.nodes()], dtype=torch.float).view(-1, 1)

# Converting to Geometric Data form

nodeToIndex = {node: i for i, node in enumerate(G.nodes())}   # Create a mapping from node identifiers to consecutive integers
edge_index = torch.tensor([[nodeToIndex[u], nodeToIndex[v]] for u, v in G.edges()], dtype=torch.long).t().contiguous()   #converting node identifiers in edge_index to integers

#PyTorch Geometric Data
data = Data(x=nodeFeatures, edge_index=edge_index)
data

#GCN model
class GCN(nn.Module):
    def __init__(self):
        super(GCN, self).__init__()
        self.conv1 = GCNConv(1, 16)          # input feature (traffic) = 1, output features = 16
        self.conv2 = GCNConv(16, 32)         # input features = 16, output features=32
        self.fc = nn.Linear(32, 1)           # Fully connected layer to predicted traffic flow

    def forward(self, data):
        x = data.x                          # Node features (initially traffic data at each node)
        x = self.conv1(x, data.edge_index)  # First GCN layer
        x = torch.relu(x)                   # Activation Relu function
        x = self.conv2(x, data.edge_index)  # Second GCN layer
        x = torch.relu(x)                   # Activation Relu function
        x = self.fc(x)                      # Fully connected layer to predict final output
        return x

model = GCN()
output = model(data)
print(output)

#Assuming output contains the predicted traffic flow from the GCN model
predicted_traffic = output.detach().numpy()
node_colors = predicted_traffic.flatten()


sm = plt.cm.ScalarMappable(cmap='viridis', norm=plt.Normalize(vmin=min(node_colors), vmax=max(node_colors)))
sm.set_array([])  #Just to avoid an error that I am facing


plt.figure(figsize=(11, 7))
nx.draw(G, pos, node_color=node_colors, cmap='viridis', with_labels=False, node_size=20)
plt.colorbar(sm, label='Predicted Traffic Flow')  # Pass the ScalarMappable object to colorbar
plt.title('Traffic Flow Prediction using GCN')
plt.show()